'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rxjs = require('rxjs');

var _operators = require('rxjs/operators');

var _resize = require('./resize');

var _resize2 = _interopRequireDefault(_resize);

var _scroll = require('./scroll');

var _scroll2 = _interopRequireDefault(_scroll);

var _orientationChange = require('./orientationChange');

var _orientationChange2 = _interopRequireDefault(_orientationChange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ROOT_MARGIN_PX = 150;

/*
  Adapted from the polyfill at https://github.com/WICG/IntersectionObserver
*/
function isIntersectionObserverSupported() {
  if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in IntersectionObserverEntry.prototype) {
    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/WICG/IntersectionObserver/issues/211
    if (!('isIntersecting' in IntersectionObserverEntry.prototype)) {
      Object.defineProperty(IntersectionObserverEntry.prototype, 'isIntersecting', {
        get() {
          return this.intersectionRatio > 0;
        }
      });
    }
    return true;
  }
  return false;
}

exports.default = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();


function createIntersectionObserverBased() {
  const intersectionObserverEntries$$ = new _rxjs.Subject();
  const intersectionObserver = new IntersectionObserver(callback, {
    threshold: 0,
    rootMargin: `${ROOT_MARGIN_PX}px`
  });

  function callback(entries) {
    entries.forEach(entry => {
      intersectionObserverEntries$$.next(entry);
    });
  }

  return function intersectionObservableFor(element) {
    return new _rxjs.Observable(observer => {
      intersectionObserver.observe(element);
      observer.next();
      return () => intersectionObserver.unobserve(element);
    }).pipe((0, _operators.mergeMap)(() => intersectionObserverEntries$$.asObservable()), (0, _operators.filter)(event => event.target === element));
  };
}

// This can be removed when intersection observer are supported by the browsers we support
function createLegacyBased() {
  function getViewport() {
    return {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: window.innerHeight
    };
  }

  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }

  function inViewport(element) {
    return () => intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
  }

  return function intersectionObservableFor(element) {
    const isElementInViewport = inViewport(element);
    return (0, _rxjs.merge)((0, _rxjs.of)(isElementInViewport()), _resize2.default, _scroll2.default, _orientationChange2.default).pipe((0, _operators.map)(isElementInViewport),
    // todo: consider "faking" more of the IntersectionObserverEntry api if possible
    (0, _operators.map)(isIntersecting => ({ isIntersecting })));
  };
}